#!/usr/bin/env python
# -*- coding: utf-8 -*-

import collections as C
import collections.abc as CA
import re
import typing as T

_U = T.TypeVar('_U')
_V = T.TypeVar('_V')
_W = T.TypeVar('_W')
_VS = T.TypeVar('_VS', bound=CA.Sequence)
_LocInfo = tuple[int, int]

CH = T.TypeVar('CH')
Text = CA.Sequence["CH"]

class ParseError(RuntimeError):
    expected: str
    text: Text
    index: int
    def __init__(self, expected: str, text: Text, index: int) -> None: ...
    @staticmethod
    def loc_info(text: Text, index: int) -> _LocInfo: ...
    def loc(self) -> str: ...
    def __str__(self) -> str: ...

class Value(C.namedtuple('Value', 'status index value expected'), T.Generic[_U]):
    @staticmethod
    def success(index: int, actual: _U) -> Value[_U]: ...
    @staticmethod
    def failure(index: int, expected: str) -> Value[_U]: ...
    def aggregate(
        self: Value[CA.Sequence[_V]], other: T.Optional[Value[CA.Sequence[_V]]] = ...
    ) -> Value[CA.Sequence[_V]]: ...
    def update_index(self, index: T.Optional[int] = None) -> Value[_U]: ...
    @staticmethod
    def combinate(values: CA.Iterable[Value[_V]]) -> Value[tuple[_V, ...]]: ...
    def __str__(self) -> str: ...

class Parser(T.Generic[_U]):
    def __init__(self, fn: CA.Callable[[Text, int], Value[_U]]) -> None: ...
    def __call__(self, text: Text, index: int) -> Value[_U]: ...
    def parse(self, text: Text) -> _U: ...
    def parse_partial(self, text: Text) -> tuple[_U, Text]: ...
    def parse_strict(self, text: Text) -> _U: ...
    @T.overload
    def bind(self, fn: CA.Callable[[_U], Parser[_V]]) -> Parser[_V]: ...
    @T.overload
    def bind(self, fn: CA.Callable[[_U, int], Parser[_V]]) -> Parser[_V]: ...
    def compose(self, other: Parser[_V]) -> Parser[_V]: ...
    def joint(self, *parsers: Parser[_U]) -> Parser[tuple[_U, ...]]: ...
    def choice(self, other: Parser[_V]) -> Parser[_U | _V]: ...
    def try_choice(self, other: Parser[_V]) -> Parser[_U | _V]: ...
    def skip(self, other: Parser[_V]) -> Parser[_U]: ...
    def ends_with(self, other: Parser[_V]) -> Parser[_U]: ...
    def excepts(self, ohter: Parser[_V]) -> Parser[_U]: ...
    def parsecmap(self, fn: CA.Callable[[_U], _V], star: bool = False) -> Parser[_V]: ...
    def map(self, fn: CA.Callable[[_U], _V], star: bool = False) -> Parser[_V]: ...
    def parsecapp(
        self: Parser[CA.Callable[[_V], _W]], other: Parser[_V]
    ) -> Parser[_W]: ...
    def apply(
        self: Parser[CA.Callable[[_V], _W]], other: Parser[_V]
    ) -> Parser[_W]: ...
    def result(self, res: _V) -> Parser[_V]: ...
    def mark(self) -> Parser[tuple[_LocInfo, _U, _LocInfo]]: ...
    def desc(self, description: str) -> Parser[_U]: ...
    def __or__(self, other: Parser[_V]) -> Parser[_U | _V]: ...
    def __xor__(self, other: Parser[_V]) -> Parser[_U | _V]: ...
    def __add__(self, other: Parser[_V]) -> Parser[tuple[_U, _V]]: ...
    def __rshift__(self, other: Parser[_V]) -> Parser[_V]: ...
    def __gt__(self, other: Parser[_V]) -> Parser[_V]: ...
    def __irshift__(self, other: CA.Callable[[_U], Parser[_V]]) -> Parser[_V]: ... # type: ignore[misc]
    def __ge__(self, other: Parser[_V]) -> Parser[_V]: ...
    def __lshift__(self, other: Parser[_V]) -> Parser[_U]: ...
    def __lt__(self, other: Parser[_V]) -> Parser[_U]: ...
    def __truediv__(self, other: Parser[_V]) -> Parser[_U]: ...

def parse(p: Parser[_V], text: Text, index: int) -> _V: ...
@T.overload
def bind(p: Parser[_U], fn: CA.Callable[[_U], Parser[_V]]) -> Parser[_V]: ...
@T.overload
def bind(p: Parser[_U], fn: CA.Callable[[_U, int], Parser[_V]]) -> Parser[_V]: ...
def compose(pa: Parser, pb: Parser[_V]) -> Parser[_V]: ...
def joint(*parsers: Parser[_U]) -> Parser[tuple[_U, ...]]: ...
def choice(pa: Parser[_U], pb: Parser[_V]) -> Parser[_U | _V]: ...
def try_choice(pa: Parser[_U], pb: Parser[_V]) -> Parser[_U | _V]: ...
def try_choices(*parsers: Parser[_U]) -> Parser[_U]: ...
def try_choices_longest(*parsers: Parser[_U]) -> Parser[_U]: ...
def skip(pa: Parser[_U], pb: Parser) -> Parser[_U]: ...
def ends_with(pa: Parser[_U], pb: Parser) -> Parser[_U]: ...
def excepts(pa: Parser[_U], pb: Parser) -> Parser[_U]: ...
def parsecmap(p: Parser[_U], fn: CA.Callable[[_U], _V]) -> Parser[_V]: ...
def parsecapp(p: Parser[CA.Callable[[_U], _V]], other: Parser[_U]) -> Parser[_V]: ...
def result(p: Parser, res: _U) -> Parser[_U]: ...
def mark(p: Parser[_U]) -> Parser[tuple[_LocInfo, _U, _LocInfo]]: ...
def desc(p: Parser[_U], description: str) -> Parser[_U]: ...
@T.overload
def generate(
    fn: str,
) -> CA.Callable[
    [CA.Callable[[], CA.Generator[Parser[_U], _U, Parser[_V] | _V]]], Parser[_V]
]: ...
@T.overload
def generate(
    fn: CA.Callable[[], CA.Generator[Parser[_U], _U, Parser[_V] | _V]]
) -> Parser[_V]: ...
def times(
    p: Parser[_U], mint: int, maxt: T.Optional[float] = ...
) -> Parser[list[_U]]: ...
def count(p: Parser[_U], n: int) -> Parser[list[_U]]: ...
def optional(
    p: Parser[_U], default_value: T.Optional[_V] = ...
) -> Parser[_U | _V | None]: ...
def many(p: Parser[_U]) -> Parser[list[_U]]: ...
def many1(p: Parser[_U]) -> Parser[list[_U]]: ...
def separated(
    p: Parser[_U],
    sep: Parser,
    mint: int,
    maxt: T.Optional[int] = ...,
    end: T.Optional[bool] = ...,
) -> Parser[list[_U]]: ...
def sepBy(p: Parser[_U], sep: Parser) -> Parser[list[_U]]: ...
def sepBy1(p: Parser[_U], sep: Parser) -> Parser[list[_U]]: ...
def endBy(p: Parser[_U], sep: Parser) -> Parser[list[_U]]: ...
def endBy1(p: Parser[_U], sep: Parser) -> Parser[list[_U]]: ...
def sepEndBy(p: Parser[_U], sep: Parser) -> Parser[list[_U]]: ...
def sepEndBy1(p: Parser[_U], sep: Parser) -> Parser[list[_U]]: ...
def satisfy(predicate: CA.Callable[[_U], bool]) -> Parser[_U]: ...
def any() -> Parser: ...
def one_of(s: CA.Container[_U]) -> Parser[_U]: ...
def none_of(s: CA.Container[_U]) -> Parser[_U]: ...
def space() -> Parser[str]: ...
def spaces() -> Parser[list[str]]: ...
def letter() -> Parser[str]: ...
def digit() -> Parser[str]: ...
def eof() -> Parser[None]: ...
def string(s: _VS) -> Parser[_VS]: ...
def regex(exp: str | re.Pattern, flags: re.RegexFlag = ...) -> Parser[str]: ...
def success_with(value: _U, advance: bool = False) -> Parser[_U]: ...
def fail_with(message: str) -> Parser: ...
def exclude(p: Parser[_U], exclude: Parser) -> Parser[_U]: ...
def lookahead(p: Parser[_U]) -> Parser[_U]: ...
def unit(p: Parser[_U]) -> Parser[_U]: ...
def between(open: Parser[_U], close: Parser[_U], parser: Parser[_U]) -> Parser[_U]: ...
def validate(predicate: CA.Callable[[_U], bool]) -> Parser[_U]: ...

sign: Parser[CA.Callable[[_U], _U]]

def number(base: int, digit: Parser[str]) -> Parser[int]: ...

binary_digit: Parser[str]
binary_number: Parser[int]
binary: Parser[int]

octal_digit: Parser[str]
octal_number: Parser[int]
octal: Parser[int]

hexadecimal_digit: Parser[str]
hexadecimal_number: Parser[int]
hexadecimal: Parser[int]

decimal_number: Parser[int]
decimal: Parser[int]

zero_number: Parser[int]
natural: Parser[int]
integer: Parser[int]
